#!/usr/bin/env python3

import sys
import socket
import select
import json
import random

# Your ID number
my_id = sys.argv[1]
# The ID of the leader
leader_id = '0000'
# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

majority = ((len(replica_ids) + 1) // 2) + 1

SELECT_WAIT_TIME = random.randrange(100, 250, 5) / 1000
HEARTBEAT_TIME = 100 / 1000

TERMINATOR = b'}\n'
buffer = b''

LEADER = 'leader'
CANDIDATE = 'candidate'
FOLLOWER = 'follower'

server_state = FOLLOWER

# STATE
# persistent state on all servers
current_term = 0
voted_for = None
log = [{'term': 0}]
# extra
database = {}

# volatile state on all servers
commit_index = 0
last_applied = 0
# extra
votes = []

# volatile state on all leaders
next_index = {}
match_index = {}


def recv_msgs():
    global buffer

    fresh_buf = sock.recv(16384)

    # is this sock shutting down?
    if len(fresh_buf) == 0:
        return None

    buffer += fresh_buf

    msgs = []
    while TERMINATOR in buffer:
        position = buffer.find(TERMINATOR) + len(TERMINATOR)
        # -1 to remove the \n, which json.loads won't want
        msgs.append(json.loads(buffer[:position - 1].decode()))
        buffer = buffer[position:]

    return msgs


def send_msg(msg):
    sock.send(json.dumps(msg).encode() + b'\n')
    print('Replica %s sent:\n%s\n' % (my_id, json.dumps(msg, indent=2)))


def create_msg(dst, type, mid):
    msg = {
        'src': my_id,
        'dst': dst,
        'leader': leader_id,
        'type': type,
        'MID': mid
    }
    return msg


def handle_get_msg(msg):
    response = None
    if server_state == LEADER:
        key = msg['key']
        response = create_msg(msg['src'], 'ok', msg['MID'])
        if key in database:
            response['value'] = database[key]
        else:
            response['value'] = ''
    elif server_state == FOLLOWER:
        response = create_msg(msg['src'], 'redirect', msg['MID'])
    send_msg(response)


def handle_put_msg(msg):
    response = None
    if server_state == LEADER:
        log.append({'term': current_term, 'key': msg['key'], 'value': msg['value']})
        database[msg['key']] = msg['value']
        response = create_msg(msg['src'], 'ok', msg['MID'])
    elif server_state == FOLLOWER:
        response = create_msg(msg['src'], 'redirect', msg['MID'])
    send_msg(response)


def handle_request_vote_msg(msg):
    if server_state != FOLLOWER:
        return
    if msg['term'] < current_term:
        return
    if not (voted_for == None or msg['candidate_id']):
        return
    # compare last terms, then compare log length
    my_last_log_term = log[len(log) - 1]['term']
    candidate_last_log_term = msg['last_log_term']
    if my_last_log_term > candidate_last_log_term:
        return
    if my_last_log_term == candidate_last_log_term and len(log) - 1 > msg['last_log_index']:
        return
    vote = {
        'src': my_id,
        'dst': msg['src'],
        'type': 'grant_vote',
        'leader': leader_id
    }
    send_msg(vote)


def handle_grant_vote_msg(msg):
    global leader_id
    global votes
    global server_state
    if server_state != CANDIDATE:
        return
    if msg['src'] not in votes:
        votes.append(votes)
        if len(votes) >= majority:
            server_state = LEADER
            leader_id = my_id
            votes = []
            for id in replica_ids:
                next_index[id] = len(log)
                match_index[id] = 0


def handle_append_entries_msg(msg):
    global current_term
    global leader_id
    if (server_state == CANDIDATE or server_state == LEADER) and msg['term'] >= current_term:
        server_state == FOLLOWER
    if server_state == FOLLOWER:
        current_term = max(msg['term'], current_term)
        leader_id = msg['leader']


def begin_leader_election():
    global current_term
    global server_state
    global voted_for
    current_term += 1
    server_state = CANDIDATE
    votes.append(my_id)
    voted_for = my_id
    print('Replica %s has started a new election\n' % my_id)
    for id in replica_ids:
        msg = {
            'src': my_id,
            'dst': id,
            'leader': leader_id,
            'type': 'request_vote',
            'term': current_term,
            'candidate_id': my_id,
            'last_log_index': len(log) - 1,
            'last_log_term': log[len(log) - 1]['term']
        }
        send_msg(msg)


def send_heartbeat():
    for id in replica_ids:
        prev_log_index = next_index[id] - 1
        prev_log_term = log[prev_log_index]['term']
        msg = {
            'src': my_id,
            'dst': id,
            'type': 'append_entries',
            'term': current_term,
            'leader': leader_id,
            'prev_log_index': prev_log_index,
            'prev_log_term': prev_log_term,
            'entries': [],
            'leader_commit': commit_index
        }
        send_msg(msg)


def handle_msg(msg):
    print('Replica %s received:\n%s\n' % (my_id, json.dumps(msg, indent=2)))
    if msg['type'] == 'get':
        handle_get_msg(msg)
    elif msg['type'] == 'put':
        handle_put_msg(msg)
    elif msg['type'] == 'request_vote':
        handle_request_vote_msg(msg)
    elif msg['type'] == 'grant_vote':
        handle_grant_vote_msg(msg)
    elif msg['type'] == 'append_entries':
        handle_append_entries_msg(msg)


# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(my_id)
print('Replica %s is up. Majority: %d. Election timeout: %dms.\n' %
      (my_id, majority, SELECT_WAIT_TIME * 1000))
while True:
    ready = None
    if server_state == LEADER:
        ready = select.select([sock], [], [], HEARTBEAT_TIME)[0]
        send_heartbeat()
    else:
        ready = select.select([sock], [], [], SELECT_WAIT_TIME)[0]
    if sock in ready:
        msgs = recv_msgs()
        for msg in msgs:
            handle_msg(msg)
    elif server_state != LEADER:
        begin_leader_election()
